//! @file
//! \brief доп функции на основе TXLib.h
//=================================================================================================================

#include "TXLib.h"


namespace drawing
{
//=================================================================================================================
// блок структур
//=================================================================================================================

//-----------------------------------------------------------------------------------------------------------------
//! \brief стиль текста 
//-----------------------------------------------------------------------------------------------------------------

	struct textStyle
	{
		std::string nameFont;	///<  названия шрифта текста
		int sizeFont;			///<  размер шрифта
	};

//=================================================================================================================
// блок констант
//=================================================================================================================

	const COLORREF TX_SCARLET = RGB(248, 0, 0); ///< алый цвет

//=================================================================================================================
//!	\brief Рисует прямоугольник с круглёными углами радиусом R
//! 
//! Используется в Buttons.h
//! \param x0, y0		координаты левего верхнего угла прямоугольника
//! \param x1, y1		координаты правого нижнего угла прямоугольника
//! \param R			радиус скругления
//! \param color		цвет рамки "мягкого" прямоугольника
//!
//-----------------------------------------------------------------------------------------------------------------

	void DrawGentleRectangle(int x0, int y0, int x1, int y1, int R, COLORREF color)
	{
		if (x1 - x0 < 2 * R) // если скругление слишком большое, то рисуем круг
		{
			txCircle((x1 - x0) / 2, (y1 - y0) / 2, R);
			return;
		}

		txSetColor(color);
		txSetFillColor(color);

		txLine(x0 + R - 1, y0, x1 - R, y0);					// верхняя сторона
		txArc(x1 - 2 * R, y0, x1, y0 + 2 * R, 0, 90);		// правый верхний угол
		txLine(x1, y0 + R - 1, x1, y1 - R);					// правая сторона
		txArc(x1 - 2 * R, y1, x1, y1 - 2 * R, -90, 90);		// правый нижний угол
		txLine(x0 + R - 1, y1, x1 - R, y1);					// нижняя сторона
		txArc(x0, y1 - 2 * R, x0 + 2 * R, y1, 180, 90);		// левый нижний угол
		txLine(x0, y0 + R - 1, x0, y1 - R);					// левая сторона
		txArc(x0, y0 + 2 * R, x0 + 2 * R, y0, 90, 90);		// левый верхний угол
	}

//-----------------------------------------------------------------------------------------------------------------
//!	\brief Рисует внутри кнопки градиент от заданого цвета до более тёмного
//! 
//! \param x0, y0		координаты левего верхнего угла кнопки
//! \param x1, y1		координаты правого нижнего угла кнопки
//! \param R			радиус скругления у кнопки
//! \param BackColor	цвет фона нажатой кнопки
//!
//-----------------------------------------------------------------------------------------------------------------

	void DrawFoneOfPushedButton(int x0, int y0, int x1, int y1, int R, COLORREF BackColor)
	{
		const int gap = MIN(x1 - x0, y1 - y0) / 2; // число эелементов градиента

		const int r = R;
		R = 0;

		if ((x1 - x0) < (y1 - y0)) // определяем координаты начальной позиции градиента
		{
			y1 -= (x1 - x0) / 2;
			y0 += (x1 - x0) / 2;
			x0 = (x1 + x0) / 2;
			x1 = x0;
		}
		else
		{
			x1 -= (y1 - y0) / 2;
			x0 += (y1 - y0) / 2;
			y0 = (y1 + y0) / 2;
			y1 = y0;
		}

		for (int i = 1; i <= gap; i++)
		{
			const COLORREF color = RGB(MAX(txExtractColor(BackColor, TX_RED) - 1.3 * i, 0),		// получаем цвет для 
							MAX(txExtractColor(BackColor, TX_GREEN) - 1.3 * i, 0),				// каждого элемента
							txExtractColor(BackColor, TX_BLUE));								// градиента

			if (gap - i <= r)			// если приблежаемся к границам кнопки делаем скругление, чтобы не было торчаших углов
				R = r - (gap - i);

			txSetColor(color);
			txSetFillColor(color);
			DrawGentleRectangle(x0, y0, x1, y1, R, color);

			//переходим к следующему элементу градиента
			x0 -= 1;
			y0 -= 1;
			x1 += 1;
			y1 += 1;
		}
	}
}